%{
#include <iostream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <cstdlib>
#include <functional>
#include <cassert>
#include <fstream>

template<typename F, typename S>
struct HashPair {
  std::size_t operator()(const std::pair<F, S> & p) const{
    std::size_t first_hash = std::hash<F>{}(p.first);
    std::size_t second_hash = std::hash<S>{}(p.second);
    return first_hash ^ (second_hash << 1);
  }
};


class TAutomata {

public:
  using TStateType = std::size_t;
  using TSizeType = std::size_t;
  using TTransitionsType = std::unordered_map<std::pair<TStateType, std::string>, TStateType, HashPair<TStateType, std::string>>;
  
public:
  bool SetStateQuantity(TSizeType size_) {
    if (size_ == 0) {
      errorDescription = "StateQuantity cannot be 0!";
      ok = false;
      return ok;
    }
    stateQuantity = size_;
    terminals.resize(stateQuantity, false);
    return ok;
  }

  bool SetTransitionsQuantity(TSizeType size_) {  
    transitionQuantity = size_;
    return ok;
  }

  bool SetInitState(TStateType init_) {
    if (!IsValidState(init_)) {
      errorDescription = "InitState must be a valid state!";
      ok = false;
      return ok;
    }
    init = init_;
    return ok;
  }
  bool AddTerminal(TStateType state_) {
    if (!IsValidState(state_)) {
      errorDescription = "TerminalState must be a valid state!";
      ok = false;
      return ok;
    }
    terminals[state_] = true;
    return ok;
  }

  bool AddSymbol(const char * symb) {
    if (symb == nullptr) {
      errorDescription = "[internal error]: Symbol is a nullptr!";
      ok = false;
      return ok;
    }
    std::string str_symb(symb);
    alphabet.insert(std::move(str_symb));
    return ok;
  }


  bool AddTransition(TStateType from, TStateType to, const char * symb) {
    if (symb == nullptr) {
      errorDescription = "[internal error]: Symbol is a nullptr!";
      ok = false;
      return ok;
    }
    if (!IsValidState(from) || !IsValidState(to)) {
      errorDescription = "State in transitions is not valid!";
      ok = false;
      return ok;
    }
    if (1 + transitions.size() > transitionQuantity) {
      errorDescription = "Too many transition!";
      ok = false;
      return ok;
    }

    std::string str_symb(symb);
    std::pair<TStateType, std::string> p = {from, str_symb};
    if (auto iter = transitions.find(p); iter != transitions.end() && iter->second != to) {
      errorDescription = "Transition from " + std::to_string(from) + " with symbol " + str_symb + " already exists!";
      ok = false;
      return ok;
    }
    realAttTransition++;
    transitions[p] = to;
    return ok;
  }

  const std::string& ErrorDescription () const {
    return errorDescription;
  }
  TSizeType Size() const {
    return stateQuantity;
  }
  bool Valid() const {
    return ok;
  }

  void PrintInfo(std::ostream &os) {
    os << "\t~~~Automat info~~~" << '\n';
    os << "State quntity: " << stateQuantity << '\n';
    os << "Init state: " << init << '\n';
    os << "Transitions function:\n";
    
    for (const auto& [key, val] : transitions) {
      os << "\t" << key.first << " + \"" << key.second << "\" --> " << val << '\n';
    }
  }

  bool EndInit() {
    for (const auto & [key, to] : transitions) {
      if (!alphabet.count(key.second)) {
        errorDescription = "The symbol in transition is not in alphabet!";
        ok = false;
        return ok;
      }
    }
    if (alphabet.size() * stateQuantity != transitionQuantity) {
      Warn("Automat is not complete!");
    }
    if (transitionQuantity != realAttTransition) {
      errorDescription = "Not enough transitions!";
      ok = false;
      return ok;
    }
    return ok;
  }

  bool Match(std::string str) {
    assert(ok > 0);
    const TStateType drain = stateQuantity;
    size_t curIdx = 0;
    TStateType curState = init;
    while (curIdx != str.size()) {
      
      char curChar = str[curIdx];
      if (auto iter = transitions.find({curState, std::string{curChar}}); iter != transitions.end()) {
        curState = iter->second;
      } 
      else {
        curState = drain;
        break;
      } 
      curIdx++;
    }
    if (curState == drain) {
      return false;
    }
    return terminals[curState];
  }

private:
bool IsValidState(TStateType state) {
  return state >= 0 && state < stateQuantity;
}

void Warn(const std::string& str) {
  std::cerr << "[WARNING] " << str << '\n';
}

private:
  TSizeType stateQuantity {};
  TSizeType transitionQuantity {};
  TStateType init {};
  TTransitionsType transitions {};
  std::vector<bool> terminals {};
  std::unordered_set<std::string> alphabet {};
  bool ok {true};
  std::string errorDescription {};
  TSizeType realAttTransition {};
};

TAutomata & automat() {
  static TAutomata response;
  return response;
}

int yylex(); 
int yyerror(const char *p) { throw std::runtime_error("Syntax error!");}

%}


%union {
  int num_val;
  const char * str_val;
};


%token <str_val> T_INVALID_TOKEN
%token <num_val> T_STATE_QUANTITY
%token <num_val> T_LINK_QUANTITY
%token <str_val> T_ALPHABET_INIT_CHAR
%token <str_val> T_ALPHABET_CHAR
%token <num_val> T_STATE
%token <str_val> T_COMMA_SEPARATOR
%token <num_val> T_EOF

%type <str_val> E_INVALID_TOKEN
%type <num_val> E_STATE_QUANTITY
%type <num_val> E_LINK_QUANTITY
%type <str_val> E_ALPHABET_INIT_CHAR
%type <str_val> E_ALPHABET_CHAR
%type <num_val> E_STATE
%type <str_val> E_COMMA_SEPARATOR

%%



start: E_STATE_QUANTITY starts_alphabet {
  bool response = automat().SetStateQuantity($1);

  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
// | E_INVALID_TOKEN


starts_alphabet: E_ALPHABET_INIT_CHAR E_COMMA_SEPARATOR starts_alphabet  {
  bool response = automat().AddSymbol($1);
  
  delete[] $1;
  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
| E_ALPHABET_INIT_CHAR starts_num_links {
  bool response = automat().AddSymbol($1);

  delete[] $1;
  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
// | E_INVALID_TOKEN

starts_num_links: E_LINK_QUANTITY starts_links {
}
// | E_INVALID_TOKEN

starts_links:
E_STATE E_COMMA_SEPARATOR E_STATE E_COMMA_SEPARATOR E_ALPHABET_CHAR starts_links {
  bool response = automat().AddTransition($1, $3, $5);

  delete[] $5;
  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
| E_STATE E_COMMA_SEPARATOR E_STATE E_COMMA_SEPARATOR E_ALPHABET_CHAR starts_init {
  bool response = automat().AddTransition($1, $3, $5);

  delete[] $5;
  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
// | E_INVALID_TOKEN 

starts_init: E_STATE starts_terminal {
  bool response = automat().SetInitState($1);
  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
// | E_INVALID_TOKEN

starts_terminal: E_STATE E_COMMA_SEPARATOR starts_terminal {
  bool response = automat().AddTerminal($1);
  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
| E_STATE {
  bool response = automat().AddTerminal($1);
  if (!response) {
    throw std::runtime_error(automat().ErrorDescription());
  }
}
| E_INVALID_TOKEN

E_INVALID_TOKEN: T_INVALID_TOKEN {throw std::runtime_error("Ivalid token!");}
E_STATE_QUANTITY: T_STATE_QUANTITY {\
  $$ = $1; 
  automat().SetStateQuantity($$);
}
E_LINK_QUANTITY: T_LINK_QUANTITY {
  $$ = $1;
  automat().SetTransitionsQuantity($$);
}
E_ALPHABET_INIT_CHAR: T_ALPHABET_INIT_CHAR {$$ = $1;}
E_ALPHABET_CHAR: T_ALPHABET_CHAR {$$ = $1;}
E_STATE: T_STATE {$$ = $1;}
E_COMMA_SEPARATOR: T_COMMA_SEPARATOR {$$ = $1;}

%%

int main(int argc, char ** argv)
{
  try {
    yyparse();
  }
  catch (std::exception & e) {
    std::cout << "Error during the parsing: " << e.what() << std::endl;
    return 1;
  }
  if (!automat().EndInit()) {
    std::cout << "Error during the parsing: " << automat().ErrorDescription() << std::endl;
    return 1;
  }

  std::ifstream in{argv[1], std::ifstream::in};
  std::string str;
  in >> str;
  std::cerr << "matching string = " << str << std::endl;
  std::cerr << "result = " << std::boolalpha << automat().Match(str) << std::endl;

  return 0;
}
