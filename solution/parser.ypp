%{
#include <iostream>
#include <string>
#include <unordered_map>
#include <string>
#include <cstdlib>
#include <functional>
#include <cassert>

int yylex(); 
int yyerror(const char *p) { std::cerr << "Error: " << p << std::endl; return 0;}

  template<typename F, typename S>
  struct HashPair {
    std::size_t operator()(const std::pair<F, S> & p) const{
      std::size_t first_hash = std::hash<F>{}(p.first);
      std::size_t second_hash = std::hash<S>{}(p.second);
      return first_hash ^ (second_hash << 1);
    }
  };


class TAutomata {

public:
  using TStateType = std::size_t;
  using TSizeType = std::size_t;
  using TTransitionsType = std::unordered_map<std::pair<TStateType, std::string>, TStateType, HashPair<TStateType, std::string>>;
  
public:
  bool SetStateQuantity(TSizeType size_) {
    if (size_ == 0) {
      errorDescription = "StateQuantity cannot be 0!";
      ok = false;
      return ok;
    }
    stateQuantity = size_;
    terminals.resize(stateQuantity, false);
    return ok;
  }

  bool SetTransitionsQuantity(TSizeType size_) {
    transitionQuantity = size_;
    return ok;
  }

  bool SetInitState(TStateType init_) {
    if (!IsValidState(init_)) {
      errorDescription = "InitState must be a valid state!";
      ok = false;
      return ok;
    }
    init = init_;
    return ok;
  }
  bool AddTerminal(TStateType state_) {
    if (!IsValidState(state_)) {
      errorDescription = "TerminalState must be a valid state!";
      ok = false;
      return ok;
    }
    terminals.push_back(state_);
  }

  bool AddSymbol(const char * symb) {
    if (symb == nullptr) {
      errorDescription = "[internal error]: Symbol is a nullptr!";
      ok = false;
      return ok;
    }
    std::string str_symb(symb);
    alphabet.push_back(std::move(str_symb));
    return ok;
  }


  bool AddTransition(TStateType from, TStateType to, const char * symb) {
    if (symb == nullptr) {
      errorDescription = "[internal error]: Symbol is a nullptr!";
      ok = false;
      return ok;
    }
    if (!IsValidState(from) || !IsValidState(to)) {
      errorDescription = "State in transitions is not valid!";
      ok = false;
      return ok;
    }
    if (1 + transitions.size() > transitionQuantity) {
      errorDescription = "Too many transition!";
      ok = false;
      return ok;
    }

    std::string str_symb(symb);
    std::pair<TStateType, std::string> p = {from, str_symb};
    if (transitions.find(p) != transitions.end()) {
      errorDescription = "Transition from " + std::to_string(from) + " with symbol " + str_symb + " already exists!";
      ok = false;
      return ok;
    }
    transitions[p] = to;
    return ok;
  }

  const std::string& ErrorDescription () const {
    return errorDescription;
  }
  TSizeType Size() const {
    return stateQuantity;
  }
  bool Valid() const {
    return ok;
  }

  void PrintInfo(std::ostream &os) {
    os << "State quntity: " << stateQuantity << '\n';
    os << "Init state: " << init << '\n';
    os << "Transitions function:\n";
    
    for (const auto& [key, val] : transitions) {
      os << "\t" << key.first << " + \"" << key.second << "\" --> " << val << '\n';
    }
  }

  bool Match(std::string str) {
    assert(ok > 0);
    const TStateType drain = stateQuantity;
    size_t curIdx = 0;
    TStateType curState = init;
    while (curIdx != str.size()) {
      char curChar = str[curIdx++];
      if (auto iter = transitions.find({curState, std::to_string(curChar)}); iter != transitions.end()) {
        curState = iter->second;
      } 
      else {
        curState = drain;
        break;
      } 
    }
    if (curState == drain) {
      return false;
    }
    return terminals[curState];
  }

private:
bool IsValidState(TStateType state) {
  return state >= 0 && state < stateQuantity;
}
private:
  TSizeType stateQuantity {};
  TSizeType transitionQuantity {};
  TStateType init {};
  TTransitionsType transitions {};
  std::vector<bool> terminals {};
  std::vector<std::string> alphabet {};
  bool ok {true};
  std::string errorDescription {};
};

TAutomata & automat() {
  static TAutomata response;
  return response;
}
%}



/*
enum Token {
    T_UNAVAIL,
    T_INVALID_TOKEN,
    T_STATE_QUANTITY,
    T_LINK_QUANTITY,
    T_ALPHABET_INIT_CHAR,
    T_ALPHABET_CHAR,
    T_STATE,
    T_COMMA_SEPARATOR,
    // T_EOF
};
*/

%union {
  int num_val;
  char * str_val;
};


%token <str_val> T_INVALID_TOKEN
%token <num_val> T_STATE_QUANTITY
%token <num_val> T_LINK_QUANTITY
%token <str_val> T_ALPHABET_INIT_CHAR
%token <str_val> T_ALPHABET_CHAR
%token <num_val> T_STATE
%token <str_val> T_COMMA_SEPARATOR
%token <num_val> T_EOF

// %type  <str_val> alphabet

%type <str_val> E_INVALID_TOKEN
%type <num_val> E_STATE_QUANTITY
%type <num_val> E_LINK_QUANTITY
%type <str_val> E_ALPHABET_INIT_CHAR
%type <str_val> E_ALPHABET_CHAR
%type <num_val> E_STATE
%type <str_val> E_COMMA_SEPARATOR

%%



start: E_STATE_QUANTITY starts_alphabet {
  std::cout << "state quantity = " << $1 << std::endl;
  std::cout << "Ok: " << automat().SetStateQuantity($1) << std::endl;
}
| E_INVALID_TOKEN


starts_alphabet: E_ALPHABET_INIT_CHAR E_COMMA_SEPARATOR starts_alphabet  {
  std::cout << "ABC: " << $1 << std::endl;
  std::cout << "Ok: " << automat().AddSymbol($1) << std::endl;

  delete[] $1;
}
| E_ALPHABET_INIT_CHAR starts_num_links {
  std::cout << "ABC: " << $1 << std::endl;
  std::cout << "Ok: " << automat().AddSymbol($1) << std::endl;

  delete[] $1;
}
| E_INVALID_TOKEN

starts_num_links: E_LINK_QUANTITY starts_links {
  std::cout << "link quantity = " << $1 << '\n';
  std::cout << "OK: " << automat().SetTransitionsQuantity($1) << std::endl;
}
| E_INVALID_TOKEN

starts_links:
E_STATE E_COMMA_SEPARATOR E_STATE E_COMMA_SEPARATOR E_ALPHABET_CHAR starts_links {
  std::cout << $1 << " --> " << $3 << " with " << $5 << std::endl;
  std::cout << "Ok: " << automat().AddTransition($1, $3, $5) << std::endl;
  std::cout << "Error: " << automat().ErrorDescription() << std::endl;
  std::cout << "Automata size: " << automat().Size() << std::endl;

  delete[] $5;
}
| E_STATE E_COMMA_SEPARATOR E_STATE E_COMMA_SEPARATOR E_ALPHABET_CHAR starts_init {
  std::cout << $1 << " --> " << $3 << " with " << $5 << std::endl;
  std::cout << "Ok: " << automat().AddTransition($1, $3, $5) << std::endl;
  std::cout << "Error: " << automat().ErrorDescription() << std::endl;
  std::cout << "Automata size: " << automat().Size() << std::endl;
  delete[] $5;
}
| E_INVALID_TOKEN 

starts_init: E_STATE starts_terminal { std::cout << "Init: " << $1 << std::endl;}
| E_INVALID_TOKEN

starts_terminal: E_STATE E_COMMA_SEPARATOR starts_terminal {std::cout << "Terminal: " << $1 << std::endl;}
| E_STATE {std::cerr << "Terminal: " << $1 << " + EOF" << std::endl;}
| E_INVALID_TOKEN

E_INVALID_TOKEN: T_INVALID_TOKEN {throw std::runtime_error("Ivalid token!\n");}
E_STATE_QUANTITY: T_STATE_QUANTITY {\
  $$ = $1; 
  automat().SetStateQuantity($$);
}
E_LINK_QUANTITY: T_LINK_QUANTITY {
  $$ = $1;
  automat().SetTransitionsQuantity($$);
}
E_ALPHABET_INIT_CHAR: T_ALPHABET_INIT_CHAR {$$ = $1;}
E_ALPHABET_CHAR: T_ALPHABET_CHAR {$$ = $1;}
E_STATE: T_STATE {$$ = $1;}
E_COMMA_SEPARATOR: T_COMMA_SEPARATOR {$$ = $1;}

%%

int main()
{
  try {
    yyparse();
  }
  catch (std::exception & e) {
    std::cout << e.what() << std::endl;
    return 0;
  }
  if (!automat().Valid()) {
    std::cout << automat().ErrorDescription() << std::endl;
  }


  std::cout << "Parsing is done!\n";
  automat().PrintInfo(std::cout);
  return 0;
}
